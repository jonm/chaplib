package org.chaplib;

import java.util.concurrent.Callable;
import java.util.concurrent.CountDownLatch;

/**
 * A <code>RequestCollapser</code> allows multiple threads
 * to coordinate and share the result of a single,
 * presumably long-running request.
 *
 * @param <T> the type of result generated by the request
 */
public class RequestCollapser<T> {

    private Callable<T> request;
    private T result;
    private boolean finished = false;
    private CountDownLatch latch = null;
    
    /**
     * Creates a <code>RequestCollapser</code> that will
     * execute the given request exactly once, and share
     * it with as many threads show up while the request
     * is outstanding. The request will not be executed
     * until at least one thread issues a <code>get()</code>
     * on this collapser.
     * @param request the (long-running) backend request
     *   whose result is to be shared
     */
    public RequestCollapser(Callable<T> request) {
        this.request = request;
    }
    
    /**
     * Executes the backend request and returns the result,
     * or waits to share the result if another thread is
     * already executing the request. As many threads as
     * desired may share the result as long as the backend
     * request is still outstanding.
     * @return result of the request
     * @throws {@link TooLateException} if the request has
     *   already been completed
     */
    public T get() {
        if (firstOneToCreateLatch()) {
            performRequestInThisThread();
        } else {
            waitForOtherThreadToFinishRequest();
        }
        return result;
    }
    
    private synchronized boolean firstOneToCreateLatch() {
        if (finished) {
            throw new TooLateException("cannot collapse requests after " +
                    "actual backend request has already completed");
        }
        if (latch != null) return false;
        latch = new CountDownLatch(1);
        return true;
    }

    private void performRequestInThisThread() {
        result = executeRequest();
        recordRequestWasCompleted();
    }

    private void waitForOtherThreadToFinishRequest() {
        while(true) {
            try {
                latch.await();
                break;
            } catch (InterruptedException e) {
            }
        }
    }

    private T executeRequest() {
        try {
            return request.call();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    private synchronized void recordRequestWasCompleted() {
        finished = true;
        latch.countDown();
    }

    /**
     * Indicates whether the backend request has completed
     * (true) or is still outstanding (false).
     */
    public synchronized boolean isFinished() {
        return finished;
    }

}
